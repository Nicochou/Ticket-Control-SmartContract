{"ast":null,"code":"\"use strict\";\n\nimport _inherits from \"D:\\\\Projets\\\\group-790626\\\\jobillet\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:\\\\Projets\\\\group-790626\\\\jobillet\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"D:\\\\Projets\\\\group-790626\\\\jobillet\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Projets\\\\group-790626\\\\jobillet\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n;\nvar _constructorGuard = {};\nvar ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nvar ModifiersNest = {\n  calldata: true,\n  memory: true\n};\n\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n\n  return false;\n} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\n\nfunction parseParamType(param, allowIndexed) {\n  var originalParam = param;\n\n  function throwError(i) {\n    logger.throwArgumentError(\"unexpected character at position \".concat(i), \"param\", param);\n  }\n\n  param = param.replace(/\\s/g, \" \");\n\n  function newNode(parent) {\n    var node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n\n    return node;\n  }\n\n  var parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n\n      case \")\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case \",\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = newNode(node.parent); //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n\n              if (node.indexed) {\n                throwError(i);\n              }\n\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n\n  delete parent.state;\n\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n\nfunction populate(object, params) {\n  for (var key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\n\nexport var FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readble with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport var ParamType = /*#__PURE__*/function () {\n  function ParamType(constructorGuard, params) {\n    _classCallCheck(this, ParamType);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n\n    populate(this, params);\n    var match = this.type.match(paramTypeArray);\n\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n\n    this._isParamType = true;\n    Object.freeze(this);\n  } // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n\n\n  _createClass(ParamType, [{\n    key: \"format\",\n    value: function format(_format) {\n      if (!_format) {\n        _format = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format);\n      }\n\n      if (_format === FormatTypes.json) {\n        var _result = {\n          type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n          name: this.name || undefined\n        };\n\n        if (typeof this.indexed === \"boolean\") {\n          _result.indexed = this.indexed;\n        }\n\n        if (this.components) {\n          _result.components = this.components.map(function (comp) {\n            return JSON.parse(comp.format(_format));\n          });\n        }\n\n        return JSON.stringify(_result);\n      }\n\n      var result = \"\"; // Array\n\n      if (this.baseType === \"array\") {\n        result += this.arrayChildren.format(_format);\n        result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n      } else {\n        if (this.baseType === \"tuple\") {\n          if (_format !== FormatTypes.sighash) {\n            result += this.type;\n          }\n\n          result += \"(\" + this.components.map(function (comp) {\n            return comp.format(_format);\n          }).join(_format === FormatTypes.full ? \", \" : \",\") + \")\";\n        } else {\n          result += this.type;\n        }\n      }\n\n      if (_format !== FormatTypes.sighash) {\n        if (this.indexed === true) {\n          result += \" indexed\";\n        }\n\n        if (_format === FormatTypes.full && this.name) {\n          result += \" \" + this.name;\n        }\n      }\n\n      return result;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value, allowIndexed) {\n      if (typeof value === \"string\") {\n        return ParamType.fromString(value, allowIndexed);\n      }\n\n      return ParamType.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ParamType.isParamType(value)) {\n        return value;\n      }\n\n      return new ParamType(_constructorGuard, {\n        name: value.name || null,\n        type: verifyType(value.type),\n        indexed: value.indexed == null ? null : !!value.indexed,\n        components: value.components ? value.components.map(ParamType.fromObject) : null\n      });\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, allowIndexed) {\n      function ParamTypify(node) {\n        return ParamType.fromObject({\n          name: node.name,\n          type: node.type,\n          indexed: node.indexed,\n          components: node.components\n        });\n      }\n\n      return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n  }, {\n    key: \"isParamType\",\n    value: function isParamType(value) {\n      return !!(value != null && value._isParamType);\n    }\n  }]);\n\n  return ParamType;\n}();\n;\n\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(function (param) {\n    return ParamType.fromString(param, allowIndex);\n  });\n}\n\nexport var Fragment = /*#__PURE__*/function () {\n  function Fragment(constructorGuard, params) {\n    _classCallCheck(this, Fragment);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n\n  _createClass(Fragment, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n\n      if (typeof value === \"string\") {\n        return Fragment.fromString(value);\n      }\n\n      return Fragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n\n      switch (value.type) {\n        case \"function\":\n          return FunctionFragment.fromObject(value);\n\n        case \"event\":\n          return EventFragment.fromObject(value);\n\n        case \"constructor\":\n          return ConstructorFragment.fromObject(value);\n\n        case \"fallback\":\n        case \"receive\":\n          // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n          return null;\n      }\n\n      return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n      value = value.replace(/\\s/g, \" \");\n      value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n      value = value.trim();\n\n      if (value.split(\" \")[0] === \"event\") {\n        return EventFragment.fromString(value.substring(5).trim());\n      } else if (value.split(\" \")[0] === \"function\") {\n        return FunctionFragment.fromString(value.substring(8).trim());\n      } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n        return ConstructorFragment.fromString(value.trim());\n      }\n\n      return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return !!(value && value._isFragment);\n    }\n  }]);\n\n  return Fragment;\n}();\nexport var EventFragment = /*#__PURE__*/function (_Fragment) {\n  _inherits(EventFragment, _Fragment);\n\n  var _super = _createSuper(EventFragment);\n\n  function EventFragment() {\n    _classCallCheck(this, EventFragment);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EventFragment, [{\n    key: \"format\",\n    value: function format(_format2) {\n      if (!_format2) {\n        _format2 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format2]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format2);\n      }\n\n      if (_format2 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"event\",\n          anonymous: this.anonymous,\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format2));\n          })\n        });\n      }\n\n      var result = \"\";\n\n      if (_format2 !== FormatTypes.sighash) {\n        result += \"event \";\n      }\n\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format2);\n      }).join(_format2 === FormatTypes.full ? \", \" : \",\") + \") \";\n\n      if (_format2 !== FormatTypes.sighash) {\n        if (this.anonymous) {\n          result += \"anonymous \";\n        }\n      }\n\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return EventFragment.fromString(value);\n      }\n\n      return EventFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (EventFragment.isEventFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"event\") {\n        logger.throwArgumentError(\"invalid event object\", \"value\", value);\n      }\n\n      var params = {\n        name: verifyIdentifier(value.name),\n        anonymous: value.anonymous,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        type: \"event\"\n      };\n      return new EventFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var match = value.match(regexParen);\n\n      if (!match) {\n        logger.throwArgumentError(\"invalid event string\", \"value\", value);\n      }\n\n      var anonymous = false;\n      match[3].split(\" \").forEach(function (modifier) {\n        switch (modifier.trim()) {\n          case \"anonymous\":\n            anonymous = true;\n            break;\n\n          case \"\":\n            break;\n\n          default:\n            logger.warn(\"unknown modifier: \" + modifier);\n        }\n      });\n      return EventFragment.fromObject({\n        name: match[1].trim(),\n        anonymous: anonymous,\n        inputs: parseParams(match[2], true),\n        type: \"event\"\n      });\n    }\n  }, {\n    key: \"isEventFragment\",\n    value: function isEventFragment(value) {\n      return value && value._isFragment && value.type === \"event\";\n    }\n  }]);\n\n  return EventFragment;\n}(Fragment);\n\nfunction parseGas(value, params) {\n  params.gas = null;\n  var comps = value.split(\"@\");\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n\n  return value;\n}\n\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(function (modifier) {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\n\nfunction verifyState(value) {\n  var result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability; // Set (and check things are consistent) the constant property\n\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    } // Set (and check things are consistent) the payable property\n\n\n    result.payable = result.stateMutability === \"payable\";\n\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable; // If payable we can assume non-constant; otherwise we can't assume\n\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    result.constant = !!value.constant;\n\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n\n  return result;\n}\n\nexport var ConstructorFragment = /*#__PURE__*/function (_Fragment2) {\n  _inherits(ConstructorFragment, _Fragment2);\n\n  var _super2 = _createSuper(ConstructorFragment);\n\n  function ConstructorFragment() {\n    _classCallCheck(this, ConstructorFragment);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ConstructorFragment, [{\n    key: \"format\",\n    value: function format(_format3) {\n      if (!_format3) {\n        _format3 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format3]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format3);\n      }\n\n      if (_format3 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"constructor\",\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payble: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format3));\n          })\n        });\n      }\n\n      if (_format3 === FormatTypes.sighash) {\n        logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"format(sighash)\"\n        });\n      }\n\n      var result = \"constructor(\" + this.inputs.map(function (input) {\n        return input.format(_format3);\n      }).join(_format3 === FormatTypes.full ? \", \" : \",\") + \") \";\n\n      if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n        result += this.stateMutability + \" \";\n      }\n\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return ConstructorFragment.fromString(value);\n      }\n\n      return ConstructorFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ConstructorFragment.isConstructorFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n      }\n\n      var state = verifyState(value);\n\n      if (state.constant) {\n        logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n      }\n\n      var params = {\n        name: null,\n        type: value.type,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new ConstructorFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"constructor\"\n      };\n      value = parseGas(value, params);\n      var parens = value.match(regexParen);\n\n      if (!parens || parens[1].trim() !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n      }\n\n      params.inputs = parseParams(parens[2].trim(), false);\n      parseModifiers(parens[3].trim(), params);\n      return ConstructorFragment.fromObject(params);\n    }\n  }, {\n    key: \"isConstructorFragment\",\n    value: function isConstructorFragment(value) {\n      return value && value._isFragment && value.type === \"constructor\";\n    }\n  }]);\n\n  return ConstructorFragment;\n}(Fragment);\nexport var FunctionFragment = /*#__PURE__*/function (_ConstructorFragment) {\n  _inherits(FunctionFragment, _ConstructorFragment);\n\n  var _super3 = _createSuper(FunctionFragment);\n\n  function FunctionFragment() {\n    _classCallCheck(this, FunctionFragment);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(FunctionFragment, [{\n    key: \"format\",\n    value: function format(_format4) {\n      if (!_format4) {\n        _format4 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format4]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format4);\n      }\n\n      if (_format4 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"function\",\n          name: this.name,\n          constant: this.constant,\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payble: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format4));\n          }),\n          ouputs: this.outputs.map(function (output) {\n            return JSON.parse(output.format(_format4));\n          })\n        });\n      }\n\n      var result = \"\";\n\n      if (_format4 !== FormatTypes.sighash) {\n        result += \"function \";\n      }\n\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format4);\n      }).join(_format4 === FormatTypes.full ? \", \" : \",\") + \") \";\n\n      if (_format4 !== FormatTypes.sighash) {\n        if (this.stateMutability) {\n          if (this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n          }\n        } else if (this.constant) {\n          result += \"view \";\n        }\n\n        if (this.outputs && this.outputs.length) {\n          result += \"returns (\" + this.outputs.map(function (output) {\n            return output.format(_format4);\n          }).join(\", \") + \") \";\n        }\n\n        if (this.gas != null) {\n          result += \"@\" + this.gas.toString() + \" \";\n        }\n      }\n\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return FunctionFragment.fromString(value);\n      }\n\n      return FunctionFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (FunctionFragment.isFunctionFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"function\") {\n        logger.throwArgumentError(\"invalid function object\", \"value\", value);\n      }\n\n      var state = verifyState(value);\n      var params = {\n        type: value.type,\n        name: verifyIdentifier(value.name),\n        constant: state.constant,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new FunctionFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"function\"\n      };\n      value = parseGas(value, params);\n      var comps = value.split(\" returns \");\n\n      if (comps.length > 2) {\n        logger.throwArgumentError(\"invalid function string\", \"value\", value);\n      }\n\n      var parens = comps[0].match(regexParen);\n\n      if (!parens) {\n        logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n      }\n\n      params.name = parens[1].trim();\n\n      if (params.name) {\n        verifyIdentifier(params.name);\n      }\n\n      params.inputs = parseParams(parens[2], false);\n      parseModifiers(parens[3].trim(), params); // We have outputs\n\n      if (comps.length > 1) {\n        var returns = comps[1].match(regexParen);\n\n        if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n          logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n        }\n\n        params.outputs = parseParams(returns[2], false);\n      } else {\n        params.outputs = [];\n      }\n\n      return FunctionFragment.fromObject(params);\n    }\n  }, {\n    key: \"isFunctionFragment\",\n    value: function isFunctionFragment(value) {\n      return value && value._isFragment && value.type === \"function\";\n    }\n  }]);\n\n  return FunctionFragment;\n}(ConstructorFragment); //export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  } // @TODO: more verification\n\n\n  return type;\n}\n\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(\"invalid identifier \\\"\".concat(value, \"\\\"\"), \"value\", value);\n  }\n\n  return value;\n}\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = \"\";\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["D:/Projets/group-790626/jobillet/client/node_modules/@ethersproject/abi/lib.esm/fragments.js"],"names":["BigNumber","defineReadOnly","Logger","version","logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","type","name","indexOf","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructorGuard","errors","UNSUPPORTED_OPERATION","operation","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","format","result","undefined","map","comp","JSON","parse","stringify","String","join","value","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","trim","split","substring","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","from","parseModifiers","constant","payable","stateMutability","console","log","verifyState","payble","toNumber","isConstructorFragment","parens","ouputs","outputs","output","toString","isFunctionFragment","returns","regexIdentifier","accum","depth","offset"],"mappings":"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","sourcesContent":["\"use strict\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n;\r\nconst _constructorGuard = {};\r\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\r\nlet ModifiersNest = { calldata: true, memory: true };\r\nfunction checkModifier(type, name) {\r\n    if (type === \"bytes\" || type === \"string\") {\r\n        if (ModifiersBytes[name]) {\r\n            return true;\r\n        }\r\n    }\r\n    else if (type === \"address\") {\r\n        if (name === \"payable\") {\r\n            return true;\r\n        }\r\n    }\r\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\r\n        if (ModifiersNest[name]) {\r\n            return true;\r\n        }\r\n    }\r\n    if (ModifiersBytes[name] || name === \"payable\") {\r\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\r\n    }\r\n    return false;\r\n}\r\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\r\nfunction parseParamType(param, allowIndexed) {\r\n    let originalParam = param;\r\n    function throwError(i) {\r\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\r\n    }\r\n    param = param.replace(/\\s/g, \" \");\r\n    function newNode(parent) {\r\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\r\n        if (allowIndexed) {\r\n            node.indexed = false;\r\n        }\r\n        return node;\r\n    }\r\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\r\n    let node = parent;\r\n    for (let i = 0; i < param.length; i++) {\r\n        let c = param[i];\r\n        switch (c) {\r\n            case \"(\":\r\n                if (node.state.allowType && node.type === \"\") {\r\n                    node.type = \"tuple\";\r\n                }\r\n                else if (!node.state.allowParams) {\r\n                    throwError(i);\r\n                }\r\n                node.state.allowType = false;\r\n                node.type = verifyType(node.type);\r\n                node.components = [newNode(node)];\r\n                node = node.components[0];\r\n                break;\r\n            case \")\":\r\n                delete node.state;\r\n                if (node.name === \"indexed\") {\r\n                    if (!allowIndexed) {\r\n                        throwError(i);\r\n                    }\r\n                    node.indexed = true;\r\n                    node.name = \"\";\r\n                }\r\n                if (checkModifier(node.type, node.name)) {\r\n                    node.name = \"\";\r\n                }\r\n                node.type = verifyType(node.type);\r\n                let child = node;\r\n                node = node.parent;\r\n                if (!node) {\r\n                    throwError(i);\r\n                }\r\n                delete child.parent;\r\n                node.state.allowParams = false;\r\n                node.state.allowName = true;\r\n                node.state.allowArray = true;\r\n                break;\r\n            case \",\":\r\n                delete node.state;\r\n                if (node.name === \"indexed\") {\r\n                    if (!allowIndexed) {\r\n                        throwError(i);\r\n                    }\r\n                    node.indexed = true;\r\n                    node.name = \"\";\r\n                }\r\n                if (checkModifier(node.type, node.name)) {\r\n                    node.name = \"\";\r\n                }\r\n                node.type = verifyType(node.type);\r\n                let sibling = newNode(node.parent);\r\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\r\n                node.parent.components.push(sibling);\r\n                delete node.parent;\r\n                node = sibling;\r\n                break;\r\n            // Hit a space...\r\n            case \" \":\r\n                // If reading type, the type is done and may read a param or name\r\n                if (node.state.allowType) {\r\n                    if (node.type !== \"\") {\r\n                        node.type = verifyType(node.type);\r\n                        delete node.state.allowType;\r\n                        node.state.allowName = true;\r\n                        node.state.allowParams = true;\r\n                    }\r\n                }\r\n                // If reading name, the name is done\r\n                if (node.state.allowName) {\r\n                    if (node.name !== \"\") {\r\n                        if (node.name === \"indexed\") {\r\n                            if (!allowIndexed) {\r\n                                throwError(i);\r\n                            }\r\n                            if (node.indexed) {\r\n                                throwError(i);\r\n                            }\r\n                            node.indexed = true;\r\n                            node.name = \"\";\r\n                        }\r\n                        else if (checkModifier(node.type, node.name)) {\r\n                            node.name = \"\";\r\n                        }\r\n                        else {\r\n                            node.state.allowName = false;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case \"[\":\r\n                if (!node.state.allowArray) {\r\n                    throwError(i);\r\n                }\r\n                node.type += c;\r\n                node.state.allowArray = false;\r\n                node.state.allowName = false;\r\n                node.state.readArray = true;\r\n                break;\r\n            case \"]\":\r\n                if (!node.state.readArray) {\r\n                    throwError(i);\r\n                }\r\n                node.type += c;\r\n                node.state.readArray = false;\r\n                node.state.allowArray = true;\r\n                node.state.allowName = true;\r\n                break;\r\n            default:\r\n                if (node.state.allowType) {\r\n                    node.type += c;\r\n                    node.state.allowParams = true;\r\n                    node.state.allowArray = true;\r\n                }\r\n                else if (node.state.allowName) {\r\n                    node.name += c;\r\n                    delete node.state.allowArray;\r\n                }\r\n                else if (node.state.readArray) {\r\n                    node.type += c;\r\n                }\r\n                else {\r\n                    throwError(i);\r\n                }\r\n        }\r\n    }\r\n    if (node.parent) {\r\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\r\n    }\r\n    delete parent.state;\r\n    if (node.name === \"indexed\") {\r\n        if (!allowIndexed) {\r\n            throwError(originalParam.length - 7);\r\n        }\r\n        if (node.indexed) {\r\n            throwError(originalParam.length - 7);\r\n        }\r\n        node.indexed = true;\r\n        node.name = \"\";\r\n    }\r\n    else if (checkModifier(node.type, node.name)) {\r\n        node.name = \"\";\r\n    }\r\n    parent.type = verifyType(parent.type);\r\n    return parent;\r\n}\r\nfunction populate(object, params) {\r\n    for (let key in params) {\r\n        defineReadOnly(object, key, params[key]);\r\n    }\r\n}\r\nexport const FormatTypes = Object.freeze({\r\n    // Bare formatting, as is needed for computing a sighash of an event or function\r\n    sighash: \"sighash\",\r\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\r\n    minimal: \"minimal\",\r\n    // Human-Readble with nice spacing, including all names\r\n    full: \"full\",\r\n    // JSON-format a la Solidity\r\n    json: \"json\"\r\n});\r\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\r\nexport class ParamType {\r\n    constructor(constructorGuard, params) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new ParamType()\"\r\n            });\r\n        }\r\n        populate(this, params);\r\n        let match = this.type.match(paramTypeArray);\r\n        if (match) {\r\n            populate(this, {\r\n                arrayLength: parseInt(match[2] || \"-1\"),\r\n                arrayChildren: ParamType.fromObject({\r\n                    type: match[1],\r\n                    components: this.components\r\n                }),\r\n                baseType: \"array\"\r\n            });\r\n        }\r\n        else {\r\n            populate(this, {\r\n                arrayLength: null,\r\n                arrayChildren: null,\r\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\r\n            });\r\n        }\r\n        this._isParamType = true;\r\n        Object.freeze(this);\r\n    }\r\n    // Format the parameter fragment\r\n    //   - sighash: \"(uint256,address)\"\r\n    //   - minimal: \"tuple(uint256,address) indexed\"\r\n    //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\r\n    format(format) {\r\n        if (!format) {\r\n            format = FormatTypes.sighash;\r\n        }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n        if (format === FormatTypes.json) {\r\n            let result = {\r\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\r\n                name: (this.name || undefined)\r\n            };\r\n            if (typeof (this.indexed) === \"boolean\") {\r\n                result.indexed = this.indexed;\r\n            }\r\n            if (this.components) {\r\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\r\n            }\r\n            return JSON.stringify(result);\r\n        }\r\n        let result = \"\";\r\n        // Array\r\n        if (this.baseType === \"array\") {\r\n            result += this.arrayChildren.format(format);\r\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\r\n        }\r\n        else {\r\n            if (this.baseType === \"tuple\") {\r\n                if (format !== FormatTypes.sighash) {\r\n                    result += this.type;\r\n                }\r\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\r\n            }\r\n            else {\r\n                result += this.type;\r\n            }\r\n        }\r\n        if (format !== FormatTypes.sighash) {\r\n            if (this.indexed === true) {\r\n                result += \" indexed\";\r\n            }\r\n            if (format === FormatTypes.full && this.name) {\r\n                result += \" \" + this.name;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static from(value, allowIndexed) {\r\n        if (typeof (value) === \"string\") {\r\n            return ParamType.fromString(value, allowIndexed);\r\n        }\r\n        return ParamType.fromObject(value);\r\n    }\r\n    static fromObject(value) {\r\n        if (ParamType.isParamType(value)) {\r\n            return value;\r\n        }\r\n        return new ParamType(_constructorGuard, {\r\n            name: (value.name || null),\r\n            type: verifyType(value.type),\r\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\r\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\r\n        });\r\n    }\r\n    static fromString(value, allowIndexed) {\r\n        function ParamTypify(node) {\r\n            return ParamType.fromObject({\r\n                name: node.name,\r\n                type: node.type,\r\n                indexed: node.indexed,\r\n                components: node.components\r\n            });\r\n        }\r\n        return ParamTypify(parseParamType(value, !!allowIndexed));\r\n    }\r\n    static isParamType(value) {\r\n        return !!(value != null && value._isParamType);\r\n    }\r\n}\r\n;\r\nfunction parseParams(value, allowIndex) {\r\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\r\n}\r\nexport class Fragment {\r\n    constructor(constructorGuard, params) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new Fragment()\"\r\n            });\r\n        }\r\n        populate(this, params);\r\n        this._isFragment = true;\r\n        Object.freeze(this);\r\n    }\r\n    static from(value) {\r\n        if (Fragment.isFragment(value)) {\r\n            return value;\r\n        }\r\n        if (typeof (value) === \"string\") {\r\n            return Fragment.fromString(value);\r\n        }\r\n        return Fragment.fromObject(value);\r\n    }\r\n    static fromObject(value) {\r\n        if (Fragment.isFragment(value)) {\r\n            return value;\r\n        }\r\n        switch (value.type) {\r\n            case \"function\":\r\n                return FunctionFragment.fromObject(value);\r\n            case \"event\":\r\n                return EventFragment.fromObject(value);\r\n            case \"constructor\":\r\n                return ConstructorFragment.fromObject(value);\r\n            case \"fallback\":\r\n            case \"receive\":\r\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\r\n                return null;\r\n        }\r\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\r\n    }\r\n    static fromString(value) {\r\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\r\n        value = value.replace(/\\s/g, \" \");\r\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\r\n        value = value.trim();\r\n        if (value.split(\" \")[0] === \"event\") {\r\n            return EventFragment.fromString(value.substring(5).trim());\r\n        }\r\n        else if (value.split(\" \")[0] === \"function\") {\r\n            return FunctionFragment.fromString(value.substring(8).trim());\r\n        }\r\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\r\n            return ConstructorFragment.fromString(value.trim());\r\n        }\r\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\r\n    }\r\n    static isFragment(value) {\r\n        return !!(value && value._isFragment);\r\n    }\r\n}\r\nexport class EventFragment extends Fragment {\r\n    format(format) {\r\n        if (!format) {\r\n            format = FormatTypes.sighash;\r\n        }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"event\",\r\n                anonymous: this.anonymous,\r\n                name: this.name,\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\r\n            });\r\n        }\r\n        let result = \"\";\r\n        if (format !== FormatTypes.sighash) {\r\n            result += \"event \";\r\n        }\r\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\r\n        if (format !== FormatTypes.sighash) {\r\n            if (this.anonymous) {\r\n                result += \"anonymous \";\r\n            }\r\n        }\r\n        return result.trim();\r\n    }\r\n    static from(value) {\r\n        if (typeof (value) === \"string\") {\r\n            return EventFragment.fromString(value);\r\n        }\r\n        return EventFragment.fromObject(value);\r\n    }\r\n    static fromObject(value) {\r\n        if (EventFragment.isEventFragment(value)) {\r\n            return value;\r\n        }\r\n        if (value.type !== \"event\") {\r\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\r\n        }\r\n        const params = {\r\n            name: verifyIdentifier(value.name),\r\n            anonymous: value.anonymous,\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\r\n            type: \"event\"\r\n        };\r\n        return new EventFragment(_constructorGuard, params);\r\n    }\r\n    static fromString(value) {\r\n        let match = value.match(regexParen);\r\n        if (!match) {\r\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\r\n        }\r\n        let anonymous = false;\r\n        match[3].split(\" \").forEach((modifier) => {\r\n            switch (modifier.trim()) {\r\n                case \"anonymous\":\r\n                    anonymous = true;\r\n                    break;\r\n                case \"\":\r\n                    break;\r\n                default:\r\n                    logger.warn(\"unknown modifier: \" + modifier);\r\n            }\r\n        });\r\n        return EventFragment.fromObject({\r\n            name: match[1].trim(),\r\n            anonymous: anonymous,\r\n            inputs: parseParams(match[2], true),\r\n            type: \"event\"\r\n        });\r\n    }\r\n    static isEventFragment(value) {\r\n        return (value && value._isFragment && value.type === \"event\");\r\n    }\r\n}\r\nfunction parseGas(value, params) {\r\n    params.gas = null;\r\n    let comps = value.split(\"@\");\r\n    if (comps.length !== 1) {\r\n        if (comps.length > 2) {\r\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\r\n        }\r\n        if (!comps[1].match(/^[0-9]+$/)) {\r\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\r\n        }\r\n        params.gas = BigNumber.from(comps[1]);\r\n        return comps[0];\r\n    }\r\n    return value;\r\n}\r\nfunction parseModifiers(value, params) {\r\n    params.constant = false;\r\n    params.payable = false;\r\n    params.stateMutability = \"nonpayable\";\r\n    value.split(\" \").forEach((modifier) => {\r\n        switch (modifier.trim()) {\r\n            case \"constant\":\r\n                params.constant = true;\r\n                break;\r\n            case \"payable\":\r\n                params.payable = true;\r\n                params.stateMutability = \"payable\";\r\n                break;\r\n            case \"pure\":\r\n                params.constant = true;\r\n                params.stateMutability = \"pure\";\r\n                break;\r\n            case \"view\":\r\n                params.constant = true;\r\n                params.stateMutability = \"view\";\r\n                break;\r\n            case \"external\":\r\n            case \"public\":\r\n            case \"\":\r\n                break;\r\n            default:\r\n                console.log(\"unknown modifier: \" + modifier);\r\n        }\r\n    });\r\n}\r\nfunction verifyState(value) {\r\n    let result = {\r\n        constant: false,\r\n        payable: true,\r\n        stateMutability: \"payable\"\r\n    };\r\n    if (value.stateMutability != null) {\r\n        result.stateMutability = value.stateMutability;\r\n        // Set (and check things are consistent) the constant property\r\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\r\n        if (value.constant != null) {\r\n            if ((!!value.constant) !== result.constant) {\r\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\r\n            }\r\n        }\r\n        // Set (and check things are consistent) the payable property\r\n        result.payable = (result.stateMutability === \"payable\");\r\n        if (value.payable != null) {\r\n            if ((!!value.payable) !== result.payable) {\r\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\r\n            }\r\n        }\r\n    }\r\n    else if (value.payable != null) {\r\n        result.payable = !!value.payable;\r\n        // If payable we can assume non-constant; otherwise we can't assume\r\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\r\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\r\n        }\r\n        result.constant = !!value.constant;\r\n        if (result.constant) {\r\n            result.stateMutability = \"view\";\r\n        }\r\n        else {\r\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\r\n        }\r\n        if (result.payable && result.constant) {\r\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\r\n        }\r\n    }\r\n    else if (value.constant != null) {\r\n        result.constant = !!value.constant;\r\n        result.payable = !result.constant;\r\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\r\n    }\r\n    else if (value.type !== \"constructor\") {\r\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\r\n    }\r\n    return result;\r\n}\r\nexport class ConstructorFragment extends Fragment {\r\n    format(format) {\r\n        if (!format) {\r\n            format = FormatTypes.sighash;\r\n        }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"constructor\",\r\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\r\n                payble: this.payable,\r\n                gas: (this.gas ? this.gas.toNumber() : undefined),\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\r\n            });\r\n        }\r\n        if (format === FormatTypes.sighash) {\r\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"format(sighash)\"\r\n            });\r\n        }\r\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\r\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\r\n            result += this.stateMutability + \" \";\r\n        }\r\n        return result.trim();\r\n    }\r\n    static from(value) {\r\n        if (typeof (value) === \"string\") {\r\n            return ConstructorFragment.fromString(value);\r\n        }\r\n        return ConstructorFragment.fromObject(value);\r\n    }\r\n    static fromObject(value) {\r\n        if (ConstructorFragment.isConstructorFragment(value)) {\r\n            return value;\r\n        }\r\n        if (value.type !== \"constructor\") {\r\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\r\n        }\r\n        let state = verifyState(value);\r\n        if (state.constant) {\r\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\r\n        }\r\n        const params = {\r\n            name: null,\r\n            type: value.type,\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\r\n            payable: state.payable,\r\n            stateMutability: state.stateMutability,\r\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\r\n        };\r\n        return new ConstructorFragment(_constructorGuard, params);\r\n    }\r\n    static fromString(value) {\r\n        let params = { type: \"constructor\" };\r\n        value = parseGas(value, params);\r\n        let parens = value.match(regexParen);\r\n        if (!parens || parens[1].trim() !== \"constructor\") {\r\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\r\n        }\r\n        params.inputs = parseParams(parens[2].trim(), false);\r\n        parseModifiers(parens[3].trim(), params);\r\n        return ConstructorFragment.fromObject(params);\r\n    }\r\n    static isConstructorFragment(value) {\r\n        return (value && value._isFragment && value.type === \"constructor\");\r\n    }\r\n}\r\nexport class FunctionFragment extends ConstructorFragment {\r\n    format(format) {\r\n        if (!format) {\r\n            format = FormatTypes.sighash;\r\n        }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"function\",\r\n                name: this.name,\r\n                constant: this.constant,\r\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\r\n                payble: this.payable,\r\n                gas: (this.gas ? this.gas.toNumber() : undefined),\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\r\n                ouputs: this.outputs.map((output) => JSON.parse(output.format(format))),\r\n            });\r\n        }\r\n        let result = \"\";\r\n        if (format !== FormatTypes.sighash) {\r\n            result += \"function \";\r\n        }\r\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\r\n        if (format !== FormatTypes.sighash) {\r\n            if (this.stateMutability) {\r\n                if (this.stateMutability !== \"nonpayable\") {\r\n                    result += (this.stateMutability + \" \");\r\n                }\r\n            }\r\n            else if (this.constant) {\r\n                result += \"view \";\r\n            }\r\n            if (this.outputs && this.outputs.length) {\r\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\r\n            }\r\n            if (this.gas != null) {\r\n                result += \"@\" + this.gas.toString() + \" \";\r\n            }\r\n        }\r\n        return result.trim();\r\n    }\r\n    static from(value) {\r\n        if (typeof (value) === \"string\") {\r\n            return FunctionFragment.fromString(value);\r\n        }\r\n        return FunctionFragment.fromObject(value);\r\n    }\r\n    static fromObject(value) {\r\n        if (FunctionFragment.isFunctionFragment(value)) {\r\n            return value;\r\n        }\r\n        if (value.type !== \"function\") {\r\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\r\n        }\r\n        let state = verifyState(value);\r\n        const params = {\r\n            type: value.type,\r\n            name: verifyIdentifier(value.name),\r\n            constant: state.constant,\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\r\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\r\n            payable: state.payable,\r\n            stateMutability: state.stateMutability,\r\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\r\n        };\r\n        return new FunctionFragment(_constructorGuard, params);\r\n    }\r\n    static fromString(value) {\r\n        let params = { type: \"function\" };\r\n        value = parseGas(value, params);\r\n        let comps = value.split(\" returns \");\r\n        if (comps.length > 2) {\r\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\r\n        }\r\n        let parens = comps[0].match(regexParen);\r\n        if (!parens) {\r\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\r\n        }\r\n        params.name = parens[1].trim();\r\n        if (params.name) {\r\n            verifyIdentifier(params.name);\r\n        }\r\n        params.inputs = parseParams(parens[2], false);\r\n        parseModifiers(parens[3].trim(), params);\r\n        // We have outputs\r\n        if (comps.length > 1) {\r\n            let returns = comps[1].match(regexParen);\r\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\r\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\r\n            }\r\n            params.outputs = parseParams(returns[2], false);\r\n        }\r\n        else {\r\n            params.outputs = [];\r\n        }\r\n        return FunctionFragment.fromObject(params);\r\n    }\r\n    static isFunctionFragment(value) {\r\n        return (value && value._isFragment && value.type === \"function\");\r\n    }\r\n}\r\n//export class ErrorFragment extends Fragment {\r\n//}\r\n//export class StructFragment extends Fragment {\r\n//}\r\nfunction verifyType(type) {\r\n    // These need to be transformed to their full description\r\n    if (type.match(/^uint($|[^1-9])/)) {\r\n        type = \"uint256\" + type.substring(4);\r\n    }\r\n    else if (type.match(/^int($|[^1-9])/)) {\r\n        type = \"int256\" + type.substring(3);\r\n    }\r\n    // @TODO: more verification\r\n    return type;\r\n}\r\nconst regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\r\nfunction verifyIdentifier(value) {\r\n    if (!value || !value.match(regexIdentifier)) {\r\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\r\n    }\r\n    return value;\r\n}\r\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\r\nfunction splitNesting(value) {\r\n    value = value.trim();\r\n    let result = [];\r\n    let accum = \"\";\r\n    let depth = 0;\r\n    for (let offset = 0; offset < value.length; offset++) {\r\n        let c = value[offset];\r\n        if (c === \",\" && depth === 0) {\r\n            result.push(accum);\r\n            accum = \"\";\r\n        }\r\n        else {\r\n            accum += c;\r\n            if (c === \"(\") {\r\n                depth++;\r\n            }\r\n            else if (c === \")\") {\r\n                depth--;\r\n                if (depth === -1) {\r\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (accum) {\r\n        result.push(accum);\r\n    }\r\n    return result;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}